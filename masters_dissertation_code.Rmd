---
title: "UCT Masters Minor Disseration"
author: "Gustav Oosthuizen"
date: "22/09/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Importing/Loading packages

```{r, importing/loading packages}

# 1. General workflow
library(tidyverse)
library(stringr)
library(lubridate)
library(plyr)

# 2. Network Analytics
library(igraph)
library(Matrix)




```


# 1. Loading data

```{r, loading data}

# Note: There is three separate data files: i) accounts, ii) alerts, iii) transactions

# 1. Accounts
accounts_data_raw <- read.csv("accounts.csv")

# 2. Alerts
alerts_data_raw <- read.csv("alerts.csv")

# 3. Transactions
transactions_data_raw <- read.csv("transactions/transactions.csv")


### Un-directed weighted network Test and validation purposes ###

# Constructing sample network used by Bart Baesens et al. (Fraud Analytics book) - Undirected network & Undirected weighted network


# 1. Configuring sample edge and node df's

# nodes (i.e customer's accounts)
node_df <- data.frame(client_ID = LETTERS[1:20],
                      is_fraud = c(rep(F, 3), T, T, T, rep(F,2), T, rep(F,11)))

# edges (i.e customers transactions)
edge_df <- data.frame(from = c("A","A", "A", "A", "A", "A", "D", "D", "D", "D", "Q", "Q", "Q", "N","N", "N", "I", "I", "K", "K", "O", "B", "F", "F", "M"),
                      to = c("I", "T", "B", "H", "O", "G", "G", "B", "E", "F", "R", "S", "O", "M", "L", "I", "K", "G", "J", "H", "P", "C", "G", "E", "L"),
                      weight = rexp(25,0.001))


# 2. Building sample network

sample_network <- graph_from_data_frame(d = edge_df,
                                 vertices = node_df,
                                 directed = FALSE)

# visualizing the graph

fraud_colour <- if_else(V(sample_network)$is_fraud == T, "red", "green")
V(sample_network)$color <- fraud_colour
E(sample_network)$width <- 1+E(sample_network)$weight/250
plot(sample_network)

### Un-directed weighted network Test and validation purposes ###

### directed network Test and validation purposes ###

 # Test 1

# 1. Configuring sample edge and node df's

# nodes (i.e customer's accounts)
node_df <- data.frame(client_ID = LETTERS[1:20],
                      is_fraud = c(rep(F, 3), T, T, T, rep(F,2), T, rep(F,11)))

# edges (i.e customers transactions)
edge_df <- data.frame(from = c("A","A", "A", "A", "A", "A", "D", "D", "D", "D", "Q", "Q", "Q", "N","N", "N", "I", "I", "K", "K", "O", "B", "F", "F", "M"),
                      to = c("I", "T", "B", "H", "O", "G", "G", "B", "E", "F", "R", "S", "O", "M", "L", "I", "K", "G", "J", "H", "P", "C", "G", "E", "L"),
                      weight = rexp(25,0.001))


# 2. Building sample network

sample_network <- graph_from_data_frame(d = edge_df,
                                 vertices = node_df,
                                 directed = TRUE)

# visualizing the graph

fraud_colour <- if_else(V(sample_network)$is_fraud == T, "red", "green")
V(sample_network)$color <- fraud_colour
E(sample_network)$arrow.size <- 0.45

plot(sample_network)


 # Test 2
# 1. Configuring sample edge and node df's

# nodes (i.e customer's accounts)
node_df <- data.frame(client_ID = LETTERS[1:10],
                      is_fraud = c(rep(F, 3), T, T, T, rep(F,2), T, F)) 

# edges (i.e customers transactions)
edge_df <- data.frame(from = c("A", "A", "A", "A", "B", "B", "B", "C", "C", "D", "G", "G", "H", "H", "H", "J"),
                      to = c("B", "B", "F", "G", "A", "E", "I", "B", "B", "C", "H", "H", "G", "J", "I", "H"),
                      weight = c(10, 20, 5, 10, 10, 25, 5, 15, 15, 10, 20, 20, 5, 10, 15, 20) )


# 2. Building sample network

sample_network_directed <- graph_from_data_frame(d = edge_df,
                                 vertices = node_df,
                                 directed = T)

# visualizing the graph

fraud_colour <- if_else(V(sample_network_directed)$is_fraud == T, "red", "green")
V(sample_network_directed)$color <- fraud_colour
E(sample_network_directed)$arrow.size <- 0.5
#E(sample_network)$width <- 1+E(sample_network)$weight/250
plot(sample_network_directed)


### directed network Test and validation purposes ###

### transaction extraction purposes ###
# 1. Configuring sample edge and node df's

# nodes (i.e customer's accounts)
node_df <- data.frame(client_ID = LETTERS[1:20],
                      is_fraud = c(rep(F, 3), T, T, T, rep(F,2), T, rep(F,11)))

# edges (i.e customers transactions)
edge_df <- data.frame(from = c("A","A", "B", "H", "O", "G", "D", "D", "E", "F", "Q", "S", "O", "M","N", "I", "I", "G", "K", "H", "O", "B", "F", "E", "M"),
                      to = c("I", "T", "A", "A", "A", "A", "G", "B", "D", "D", "R", "Q", "Q", "N", "L", "N", "K", "I", "J", "K", "P", "C", "G", "F", "L"),
                      weight = rexp(25,0.001))


### transaction extraction purposes ###



```

# 2. Pre-local-EDA of each raw data table

```{r, prelimimary exploratory data analysis of each data set }

# 1. Accounts data

# 1.1 structure

str(accounts_data_raw)

summary(accounts_data_raw)

# 1.2 Checking uniqueness of variables

accounts_data_raw$ACCOUNT_ID %>% 
  unique() %>% 
  length()

# Note: there are 1000 accounts

accounts_data_raw$CUSTOMER_ID %>% 
  unique() %>% 
  length()

# Note: It seems like the assumption was made that the a customer only has one account.

accounts_data_raw$COUNTRY %>% 
  unique() 

# Seems like the only country is US

accounts_data_raw$ACCOUNT_TYPE %>% 
  unique()

# plotting fraudulent and not fraudent accounts

accounts_data_raw %>% 
  group_by(IS_FRAUD) %>% 
  summarise(total_count = n()) %>% 
  ggplot(aes(y = total_count, x = IS_FRAUD, fill = IS_FRAUD)) + 
  geom_col() + 
  geom_text(aes(label = total_count), vjust = 1)


# 17% is fraudulent accounts and the 83% are honest users

# plot of accounts distribution

# box and whiskers plot - initial balance

ggplot(accounts_data_raw, aes(y = IS_FRAUD, x = INIT_BALANCE)) +
  geom_boxplot()

# distribution plots

# histogram
ggplot(accounts_data_raw, aes(x = INIT_BALANCE, fill = IS_FRAUD)) +
  geom_histogram() +
  facet_wrap(~IS_FRAUD)

# density plot
ggplot(accounts_data_raw, aes(x = INIT_BALANCE, fill = IS_FRAUD)) +
  geom_density() +
  facet_wrap(~IS_FRAUD)

# 2. alerts 

str(alerts_data_raw)

summary(alerts_data_raw)

# Checking the uniqueness of each column

sapply(alerts_data_raw[sapply(alerts_data_raw, class) == "character"], unique)


# plot of alerts distribution

# box and whiskers plot - transaction amount

ggplot(alerts_data_raw, aes(x = TX_AMOUNT, y = IS_FRAUD)) +
  geom_boxplot()

# distribution - transaction amount

# histogram
ggplot(alerts_data_raw, aes(x = TX_AMOUNT)) +
  geom_histogram()

# density plot
ggplot(alerts_data_raw, aes(x = TX_AMOUNT)) +
  geom_density()

# time series plot

alerts_data_raw %>% 
ggplot(aes(x = TIMESTAMP, y = TX_AMOUNT)) + 
  geom_jitter()

# Note: No transactions were flagged that had a amount between 5 and 10 interesting to note that 

#  Histogram of received accounts

alerts_data_raw %>% 
  group_by(RECEIVER_ACCOUNT_ID) %>% 
  summarise(total_count = n()) %>% 
  arrange(desc(total_count)) %>% 
  ggplot(aes(x = total_count)) +
  geom_histogram()

#  Histogram of sender accounts

alerts_data_raw %>% 
  group_by(SENDER_ACCOUNT_ID) %>% 
  summarise(total_count = n()) %>% 
  arrange(desc(total_count)) %>% 
  ggplot(aes(x = total_count)) +
  geom_histogram()


# Count plot of the number of alert types

alerts_data_raw %>% 
  group_by(ALERT_TYPE) %>% 
  summarise(total_count = n()) %>% 
  ggplot(aes(y = total_count, x = ALERT_TYPE, fill = ALERT_TYPE)) + 
  geom_col() + 
  geom_text(aes(label = total_count), vjust = 1)


# 2. Transactions

# structure

str(transactions_data_raw)


# classes of variables

sapply(transactions_data_raw[sapply(transactions_data_raw, class) == "character"], unique)

# distributions - transactions

# box and whiskers plot
ggplot(transactions_data_raw, aes(x = TX_AMOUNT, y = IS_FRAUD)) +
  geom_boxplot() +
  scale_x_continuous(trans='log10')

# histogram
ggplot(transactions_data_raw, aes(x = TX_AMOUNT, fill = IS_FRAUD)) +
  geom_histogram() +
  facet_wrap(~IS_FRAUD) +
  scale_x_continuous(trans='log10') + 
  scale_y_continuous(trans='log10')

# density plots - fraud transactions

transactions_data_fraud <- transactions_data_raw %>% 
  filter(IS_FRAUD == "True")

# maximum density occurs at tx value of:
mode_tx_fraud <- density(transactions_data_fraud$TX_AMOUNT)$x[which.max(density(transactions_data_fraud$TX_AMOUNT)$y)]


ggplot(transactions_data_fraud, aes(TX_AMOUNT)) + 
  geom_density() + 
  geom_vline(xintercept = mode_tx_fraud)

# density plots - Non-fraud transactions (NB! something weird is heaping here!)

transactions_data_honest <- transactions_data_raw %>% 
  filter(IS_FRAUD == "False",
         TX_AMOUNT != 0)

# maximum density occurs at tx value of:
# which.max(density(transactions_data_honest$TX_AMOUNT)$y)
# 
# ggplot(transactions_data_honest, aes(TX_AMOUNT)) + 
#   geom_density() + 
#   geom_vline(xintercept = mode_tx_honest) + 
#   scale_x_log10()
         
```

# 3. Feature Extraction

# 3.1 Data pre-processing and checks

```{r, data pre-processing and checks}

# 1. Data preparation

# 1.1 transactions data & alerts data 

# joining alert type col from alerts df to transactions df 
alerts_types <- alerts_data_raw %>% 
  select(ALERT_ID, ALERT_TYPE)

transactions_data_up <- transactions_data_raw %>% 
  left_join(alerts_types, by = "ALERT_ID") %>% 
  unique()

# replacing NA values formed by transactions that are not fraud
transactions_data_up[is.na(transactions_data_up)] <- "No Alert"

# rearranging columns such that sender node and receiver node is mentioned first in the df
transactions_data_up <- transactions_data_up[,c(2,3,1,4:ncol(transactions_data_up))]


# 1.2 Setting up an initial network to check which nodes have a degree = 0

# setting up initial network 
initial_net <- graph_from_data_frame(d = transactions_data_up,
                                 vertices = accounts_data_raw,
                                 directed = FALSE)

# calculating total degree
initial_node_degree <- degree(initial_net, mode = "all", loops = F)

# extracting the account ID's which had a degree of zero
accounts_degree_zero <-  names(which(initial_node_degree == 0))

# updated accounts data
accounts_data_up <- accounts_data_raw %>% 
  filter(!ACCOUNT_ID %in%  accounts_degree_zero)


# 1.3 Creating network feature data frame (for downstream feature extraction)
network_feature_df <- data_frame(ACCOUNT_ID = accounts_data_up$ACCOUNT_ID)

# 2. Data checks 

# 2.1 nodes - accounts

nrow(accounts_data_raw)

accounts_data_raw$ACCOUNT_ID %>%
  unique() %>% 
  length()
  
# Note: there are 1000 different accounts

# 2.2 links - transactions

nrow(transactions_data_up)

nrow(unique(transactions_data_up[,c("SENDER_ACCOUNT_ID", "RECEIVER_ACCOUNT_ID")]))

# Note: There are more links than sender-receiver combination, therefore we have cases where there is multiple links between the same nodes. This will be adresed in the next code section.

```

# 3.2 Network construction - Undirected weighted network (simplified)

*Note:* The simplified graph will only consider one edge between incident nodes.

```{r, network construction and feature extraction - undirected weighted network (simplified) }

#### Un-directed weighted Network feature generation function ####

# Description: The function will take as input a sub-graph with more than 2 nodes and calculate the relevant network metrics.

# input: a weighted undirected sub-graph with more than two nodes
# output: a data frame containing all the network metrics extracted from the sub-graph. 

# NB! The function will only  be able to take as input an un-directed-weighted network.


# 1. Defining additional functions that will be used within the network feature generation function

# 1.1 Degree functions

# 1.1.1 Fraud degree calculations
fraud_degree_counter_func <- function(graph){
  
  # names of all the nodes in the network
  node_names <- V(graph)$name 
  
  # creating variable to store fraud degree counts for each node
  fraud_degree_vec <- rep(NA, length(node_names))
  
  # looping to calculate for each fraud degree
  for (i in 1:length(node_names)) {
    
    # extracting temp sub-graph for a single node
    temp_sub_graph <- induced_subgraph(graph, 
                                       vids = unlist(neighborhood(graph = graph, order = 1, nodes = node_names[i])),
                                       impl = "auto")
    
    # converting sub-graph to data_frame and filtering
    temp_fraud_degree <- as_data_frame(temp_sub_graph, what = "vertices") %>% 
      filter(name != node_names[i] & is_fraud == T) %>% 
      nrow()
    
    # saving fraud degree
    fraud_degree_vec[i] <- temp_fraud_degree
    
  }
  
  return(fraud_degree_vec)
  
}

# 1.1.2  Non-fraud degree calculations
non_fraud_degree_counter_func <- function(graph){
  
  # names of all the nodes in the network
  node_names <-V(graph)$name 
  
  # creating variable to store fraud degree counts for each node
  non_fraud_degree_vec <- rep(NA, length(node_names))
  
  # looping to calculate for each fraud degree
  for (i in 1:length(node_names)) {
    
    # extracting temp sub-graph for a single node
    temp_sub_graph <- induced_subgraph(graph, 
                                       vids = unlist(neighborhood(graph = graph, order = 1, nodes = node_names[i])),
                                       impl = "auto")
    
    # converting sub-graph to data_frame and filtering
    temp_non_fraud_degree <- as_data_frame(temp_sub_graph, what = "vertices") %>% 
      filter(name != node_names[i] & is_fraud == F) %>% 
      nrow()
    
    # saving fraud degree
    non_fraud_degree_vec[i] <- temp_non_fraud_degree
    
  }
  
  return(non_fraud_degree_vec)
  
}


# 1.2 Node density function

node_density_func <- function(graph) {
  
  # names of all the nodes in the network
  node_names <-V(graph)$name 
  
  # creating variable to store fraud degree counts for each node
  node_density_vec <- rep(NA, length(node_names))
  
  # looping to calculate for each fraud degree
  for (i in 1:length(node_names)) {
    
    # extracting temp sub-graph for a single node
    temp_sub_graph <- induced_subgraph(graph, 
                                       vids = unlist(neighborhood(graph = graph, order = 1, nodes = node_names[i])),
                                       impl = "auto")
    # calculating density and saving value
    node_density_vec[i] <- edge_density(temp_sub_graph)
    
  }
  
  return(node_density_vec)
  
}

# 1.3 Relational neighbor (classifier)

relational_neighbour_classifier_func <- function(graph) {
  
  # names of all the nodes in the network
  node_names <-V(graph)$name 
  
  # creating variable to store the probability of node being fraudulent or non-fraudulent according to its neighborhood
  prob_fraud_vec <- rep(NA, length(node_names))
  prob_non_fraud_vec <- rep(NA, length(node_names))
  
  # looping to calculate for each fraud degree
  
  for (i in 1:length(node_names)) {
    
    # extracting temp sub-graph for a single node
    temp_sub_graph <- induced_subgraph(graph, 
                                       vids = unlist(neighborhood(graph = graph, order = 1, nodes = node_names[i])),
                                       impl = "auto")
    
    # converting sub-graph to data_frame and filtering
    temp_df <- as_data_frame(temp_sub_graph, what = "vertices")
    
    # calculating number of # fraud neighbors
    temp_count_fraud <- temp_df %>% 
      filter(name != node_names[i] & is_fraud == T) %>% 
      nrow()
    
    # calculating number of # non-fraud neighbors
    temp_count_non_fraud <- temp_df %>% 
      filter(name != node_names[i] & is_fraud == F) %>% 
      nrow()
    
    # calculating nrmalisation factor (Z)
    Z =  temp_count_fraud + temp_count_non_fraud
    
    prob_fraud_vec[i] <- temp_count_fraud/Z
    
    prob_non_fraud_vec[i] <- temp_count_non_fraud/Z
    
    }
  
  probability_res <- list(prob_fraud = prob_fraud_vec,
                          prob_non_fraud = prob_non_fraud_vec) 
  
  
  return(probability_res)
  
}

# 1.4 Probabilistic relational neighbor (classifier)

prob_relational_neighbor_classifier_func <- function(graph, relational_neig_prob_fraud, relational_neig_prob_non_fraud){
  
  # adding relational neighborhood classifier results to graph
  V(graph)$relational_neig_prob_fraud <- relational_neig_prob_fraud
  V(graph)$relational_neig_prob_non_fraud <- relational_neig_prob_non_fraud
  
  # names of all the nodes in the network
  node_names <-V(graph)$name 
  
  # creating variable to store the probability of node being fraudulent or non-fraudulent according to its neighborhood
  prob_fraud_vec <- rep(NA, length(node_names))
  prob_non_fraud_vec <- rep(NA, length(node_names))
  
  # looping to calculate for each fraud degree
  for (i in 1:length(node_names)) {
    
    # extracting temp sub-graph for a single node
    temp_sub_graph <- induced_subgraph(graph, 
                                       vids = unlist(neighborhood(graph = graph, order = 1, nodes = node_names[i])),
                                       impl = "auto")
    
    # converting sub-graph to data_frame and filtering
    temp_df <- as_data_frame(temp_sub_graph, what = "vertices")
    
    # calculating number of # fraud neighbors
    temp_count_fraud <- temp_df %>% 
      filter(name != node_names[i]) %>% 
      select(relational_neig_prob_fraud) %>% 
      sum()
    
    # calculating number of # non-fraud neighbors
    temp_count_non_fraud <- temp_df %>% 
      filter(name != node_names[i]) %>% 
      select(relational_neig_prob_non_fraud) %>% 
      sum()
    
    # calculating normalization factor (Z)
    Z =  temp_count_fraud + temp_count_non_fraud
    
    prob_fraud_vec[i] <- temp_count_fraud/Z
    
    prob_non_fraud_vec[i] <- temp_count_non_fraud/Z
    
  }
    

  
  probability_res <- list(prob_fraud = prob_fraud_vec,
                          prob_non_fraud = prob_non_fraud_vec) 
  
}

# 1.5 Calculating, Fraud, Semi-Fraud, and Legit triangles

# The function below classifies all the triangles found in a network as either being legit, fraud or semi-fraud
triangle_classifier_func <- function(graph){
  
  # calculates the complete sub-graphs with 3 vertices (i.e triangles)
  cl.tri = cliques(graph,
                   min=3,
                   max=3)
  
  # constructing a data frame where each row corresponds to a triangle and each column to a node in that triangle
  df <- lapply(cl.tri, function(x){V(graph)$name[x]})
  triangles_df = data.frame(matrix(unlist(df),ncol=3,byrow=T))
  
  # creating class label for triangles (will be important later)
  triangles_df$triangle_label <- rep(NA,nrow(triangles_df))
  
  # creating a sub graph for each triangle
  for (i in 1:nrow(triangles_df)) {
    
    # counting fraud triangles
    temp_triangle <- c(triangles_df$X1[i], triangles_df$X2[i], triangles_df$X3[i])
    
    # creating sub_graph
    temp_sub_graph <- induced_subgraph(graph, 
                                       vids = temp_triangle, # triangle nodes
                                       impl = "auto")
    
    fraud_sum <- as_data_frame(temp_sub_graph, what = "vertices") %>% 
      select(is_fraud) %>% 
      sum()
    
    
    if(fraud_sum == 0){
      
      triangles_df$triangle_label[i] <- "legit_triangles"
      
    }else if(fraud_sum == 1 | fraud_sum == 2){
      
      triangles_df$triangle_label[i] <- "semi_fraud_triangles"
    }else{
      
      triangles_df$triangle_label[i] <- "fraud_triangles"
      
      } 
  }
  
  # changing df in long format
  triangles_df_long <- pivot_longer(triangles_df,
                                        cols = 1:3,
                                        names_to = "col_names",
                                        values_to = "client_ID"
                                        ) %>% 
  select(-col_names)
  
  # tabulating triangles result
  triangles_df_table_long <-  as.data.frame(t(table(triangles_df_long)))
  
  # converting to wide format
  triangles_df <- pivot_wider(triangles_df_table_long,
                              names_from = triangle_label,
                              values_from = Freq)
  
  
  
  return(triangles_df)
  
}

# 2. Defining weighted network feature generation function 

weighted_network_feature_function <- function(sub_graph, verbose = c(TRUE,FALSE)){
  
  sample_network <- sub_graph
  
  # Note: Sample network refers to the current sub-graph that is used.
  
  # 1. Extracting network metrics
  
  # 1.1 Neighborhood metrics
  
  if(verbose){print("1. Calculating neighbourhood metrics")}
  
  # 1.1.1 Transitivity - (local) ratio of triangles to connected triples each vertex is part of. Can be interpreted as a probability for the network to have adjacent nodes interconnected, thus revealing the existence of tightly connected communities (or clusters, subgroups, cliques).
  
  if(verbose){print("1.1 Calculating transitivity...")}
  
  transitivity_loc_uw <- transitivity(sample_network, 
                                      type = "local",
                                      vids = V(sample_network),
                                      isolates = "zero",
                                      weights = E(sample_network)$weight) 

  # 1.1.2 Total Degree (local) - Here the degree is defined as the number of edges between connected nodes.
  
  if(verbose){print("1.2 Calculating total degree...")}
  
  total_degree_loc_uw <- degree(sample_network, 
                                       loops = F, 
                                       mode = "all")
  # Note: Loops are not counted.
  
  # 1.1.3  Calculating fraud degree
  
  # NB! Check the name and is_fraud column in the filtering operation when bigger network is used.
  
  if(verbose){print("1.3 Calculating fraud degree...")}
  
  is_fraud_degree_loc_uw <- fraud_degree_counter_func(graph = sample_network)
  
  # 1.1.4 Calculating  Non-fraud degree
  
  if(verbose){print("1.4 Calculating non-fraud degree...")}
  
  # calculating non-fraud degree
  non_fraud_degree_loc_uw <- non_fraud_degree_counter_func(graph = sample_network)
  
  # 1.1.5 Strength (weighted degree) - Summing up the edge weights of the adjacent edges for each vertex
  
  if(verbose){print("1.5 Calculating strength...")}
  
  degree_strength_loc_uw <- strength(sample_network,
                                     loops = F,
                                     mode = "all",
                                     weights = E(sample_network)$weight # NB! will change when  weights are incorporated
  )
  
  # NB!! Try to implement degree strength for fraud and non-fraud nodes (when implementing weighted network)

  # 1.1.6  Node density: considering an each node and its neighborhood of 1, then the node density is defined as the ratio of the number of edges and the number of possible edges (which you will find in a connected graph). 
  
  if(verbose){print("1.6 Calculating node density...")}
  
  node_density_loc_uw <- node_density_func(graph = sample_network)
  
  
  # 1.1.7 Relational neighbor: Assigns a probability to node i is part of class fraud or non-fraud given the class labels of node i's neighborhood. 
  
  if(verbose){print("1.7 Calculating relational neighbour...")}
  
  # results of the relational neighborhood classifier
  relational_neig_results <- relational_neighbour_classifier_func(graph = sample_network)
  
  # probability of non-fraud
  relational_neig_prob_non_fraud_loc_uw <- relational_neig_results$prob_non_fraud
  
  # probability of fraud
  relational_neig_prob_fraud_loc_uw <- relational_neig_results$prob_fraud
  
# 1.1.8 Probabilistic relational neighbor classifier
  
  if(verbose){print("1.8 Calculating probabilistic relational neighbour...")}
  
  # results of the prob relational neighborhood classifier
  prob_relational_neig_results <- prob_relational_neighbor_classifier_func(graph = sample_network,
                                                                           relational_neig_prob_fraud = relational_neig_prob_fraud_loc_uw,
                                                                           relational_neig_prob_non_fraud = relational_neig_prob_non_fraud_loc_uw)
  
  
  # probability of non-fraud
  prob_relational_neig_prob_non_fraud_loc_uw <- prob_relational_neig_results$prob_non_fraud
  
  # probability of fraud
  prob_relational_neig_prob_fraud_loc_uw <- prob_relational_neig_results$prob_fraud
  
  
  if(verbose){print("1.9 Calculating triangles...")}
  
  # 1.1.9 Triangles - Count how many triangles a vertex is part of, in a graph, or just list the triangles of a graph.
  
  # Total triangles
  
  triangles_loc_uw <- count_triangles(sample_network)
  
  # Note: This will be the total triangles Baesens et al. (2015) broke this up into: total fraud triangles, total legit triangles, and total semi-fraud triangles. 
  
  # Calculating, Fraud, Semi-Fraud, and Legit triangles
  
  sample_triangle_df <- triangle_classifier_func(sample_network)
  
  # creating dummy data frame
  sample_triangle_df_full <- data.frame(client_ID = V(sample_network)$name)
  
  # join operation
  sample_triangle_df_full <- left_join(sample_triangle_df_full,sample_triangle_df, by = "client_ID")
  
  # replacing NA values
  sample_triangle_df_full[is.na(sample_triangle_df_full)] <- 0
  

  # 1.2 Centrality metrics
  
  if(verbose){print("2. Calculating centrality metrics")}
  
  # 1.2.1 Closeness centrality and farness - Measures the average farness (inverse distance) to all other nodes. Nodes with a high closeness score have the shortest distances to all other nodes.
  
  if(verbose){print("2.1 Calculating closeness centrality and Farness...")}
  
  centrality_closeness_loc_uw <- closeness(sample_network,
                                           normalized = T, # can think of using TRUE on full network
                                           weights = E(sample_network)$weight) # Can use weights in full network  
  
  
  farness_loc_uw <- (centrality_closeness_loc_uw)^-1
  
  
  # 1.2.2 Eigenvector centrality - Eigenvector centrality scores correspond to the values of the first eigenvector of the graph adjacency matrix; these scores may, in turn, be interpreted as arising from a reciprocal process in which the centrality of each actor is proportional to the sum of the centralities of those actors to whom he or she is connected.
  
  if(verbose){print("2.2 Calculating eigenvector centrality...")}
  
  centrality_eigen_loc_uw_res <- eigen_centrality(sample_network,
                                              scale = T,
                                              directed = F,
                                              weights = E(sample_network)$weight) #weights can be included 
  
  centrality_eigen_loc_uw <- centrality_eigen_loc_uw_res$vector
  
  
  # 1.2.3 betweeness - the number of geodesics (shortest paths) going through a vertex or an edge
  
  if(verbose){print("2.3 Calculating betweeness...")}
  
  centrality_betweenness_loc_uw <-  betweenness(sample_network,
                                                directed = F,
                                                weights = E(sample_network)$weight,
                                                normalized = F) #weights can be included
  
  # 1.2.4  Average Geodesic - average length of all shortest paths (hops to nodes)
  
  if(verbose){print("2.4 Calculating average geodesic...")}
  
  geodesic_loc_uw <- distances(sample_network,
                                      mode = "all",
                                      weights = E(sample_network)$weight, # weights can be added 
                                      algorithm = "automatic")
  
  
  # excluding nodes that are unconnected
  avg_geodesic_loc_uw <- apply(geodesic_loc_uw, 1, mean)
  
  
  # 1.3 Inference algorithms 
  
  if(verbose){print("3. Calculating collective inference algorithms...")}
  
  # 1.3.1 PageRank
  
  # base PageRank algorithm
  pr_base_loc_uw_res <- page_rank(sample_network,
                            algo = "prpack",
                            directed = F,
                            damping = 0.85,
                            weights = E(sample_network)$weight) # can add weights 
  
  pr_base_loc_uw <- pr_base_loc_uw_res$vector
  
  # PageRank algorithm with emphasis on fraud nodes
  
  # defining start vector for algorithm (0 for legitimate clients and non-zero for fraudsters)
  total_fraud_nodes <- sum(V(sample_network)$is_fraud)
  fraud_nodes_start_value <- 1/(total_fraud_nodes)
  
  start_vec_fraud <- if_else(V(sample_network)$is_fraud == F, 0, fraud_nodes_start_value)
  
  # calculating PageRank
  pr_fraud_loc_uw_res <- page_rank(sample_network,
                            algo = "prpack",
                            directed = F,
                            damping = 0.85,
                            personalized = start_vec_fraud,
                            weights = E(sample_network)$weight) # can add weights 
  
  pr_fraud_loc_uw <- pr_fraud_loc_uw_res$vector
  
  
  # 1.4 Compiling results in data frame
  
  if(verbose){print("Compiling calculated metrics in data frame...")}
  
  sample_network_feature_df <- data_frame(client_ID = V(sub_graph)$name,
                                          transitivity = transitivity_loc_uw,
                                          total_degree = total_degree_loc_uw,
                                          fraud_degree = is_fraud_degree_loc_uw,
                                          non_fraud_degree = non_fraud_degree_loc_uw,
                                          degree_strenght = degree_strength_loc_uw,
                                          node_density = node_density_loc_uw,
                                          relational_neighbour_not_fraud = relational_neig_prob_non_fraud_loc_uw,
                                          relational_neighbour_fraud = relational_neig_prob_fraud_loc_uw,
                                          probabilistic_relational_neighbour_not_fraud = prob_relational_neig_prob_non_fraud_loc_uw,
                                          probabilistic_relational_neighbour_fraud = prob_relational_neig_prob_fraud_loc_uw,
                                          total_triangles = triangles_loc_uw,
                                          legit_triangles = sample_triangle_df_full$legit_triangles,
                                          semi_fraud_triangles = sample_triangle_df_full$semi_fraud_triangles,
                                          fraud_triangles = sample_triangle_df_full$fraud_triangles,
                                          closeness_centrality = centrality_closeness_loc_uw,
                                          farness = farness_loc_uw,
                                          eigen_vector_centrality = centrality_eigen_loc_uw,
                                          betweeness = centrality_betweenness_loc_uw,
                                          avg_geodesic = avg_geodesic_loc_uw,
                                          page_rank_base = pr_base_loc_uw,
                                          page_rank_fraud = pr_fraud_loc_uw)
  

return(sample_network_feature_df)  

}

weighted_network_feature_df <-  weighted_network_feature_function(sub_graph = sample_network, verbose = T)


```

# 3.3 Network construction - Directed network (non-simplified)

```{r, network construction - directed network (non-simplified)}

#### Directed Network feature generation function ####

# Description: The function will take as input a sub-graph with more than 2 nodes and calculate the relevant network metrics.

# input: a directed sub-graph with more than two nodes
# output: a data frame containing all the network metrics extracted from the sub-graph. 

# NB! The function will only  be able to take as input an un-directed-weighted network.

# 1. Defining additional functions that will be used within the network feature generation function

# 1.1 Degree functions

# 1.1.1 Fraud degree calculations
directed_degree_counter_func <- function(graph, fraud_selection = c(TRUE, FALSE), degree_direction = c("in", "out")){
  
  # names of all the nodes in the network
  node_names <- V(graph)$name 
  
  # creating variable to store fraud degree counts for each node
  fraud_degree_vec <- rep(NA, length(node_names))
  
  if(degree_direction == "in"){
    
    # looping to calculate for each fraud degree
    for (i in 1:length(node_names)) {
      
      # extracting temp sub-graph for a single node
      temp_sub_graph <- induced_subgraph(graph, 
                                         vids = unlist(neighborhood(graph = graph, order = 1, nodes = node_names[i])),
                                         impl = "auto")
      
      # converting sub-graph to data_frame and filtering
      temp_df <- as_data_frame(temp_sub_graph, what = "both")
      
      temp_edge_df <- temp_df$edges %>%
        rename(name = from)
      
      temp_fraud_count <- left_join(temp_edge_df,temp_df$vertices, by = "name") %>% 
        filter(name != node_names[i] & to == node_names[i] & is_fraud == fraud_selection) %>% 
        nrow() 
      
      # saving fraud degree
      fraud_degree_vec[i] <- temp_fraud_count
    }
  }
  
  if(degree_direction == "out"){
    
    # looping to calculate for each fraud degree
    for (i in 1:length(node_names)) {
      
      # extracting temp sub-graph for a single node
      temp_sub_graph <- induced_subgraph(graph, 
                                         vids = unlist(neighborhood(graph = graph, order = 1, nodes = node_names[i])),
                                         impl = "auto")
      
      # converting sub-graph to data_frame and filtering
      temp_df <- as_data_frame(temp_sub_graph, what = "both")
      
      temp_edge_df <- temp_df$edges %>%
        rename(name = to)
      
      temp_fraud_count <- left_join(temp_edge_df,temp_df$vertices, by = "name") %>% 
        filter(name != node_names[i] & from == node_names[i] & is_fraud == fraud_selection) %>% 
        nrow() 
      
      # saving fraud degree
      fraud_degree_vec[i] <- temp_fraud_count
    }
  }
  
  return(fraud_degree_vec)
  
}

# 2. 

directed_network_feature_function <- function(sub_graph, verbose = c(TRUE, FALSE)){
  
  # 1. Extracting network metrics
  
  if(verbose == T){print("1. Calculating neighbourhood metrics (directed)...")}
  
  # 1.1 Neighborhood metrics
  
  if(verbose == T){print("1.1 Calculating in-degree...")}
  # 1.1.1 in-degree
  in_degree_loc_d <- degree(sub_graph, 
                            mode = "in",
                            loops = F,
                            normalized = F)
  
  if(verbose == T){print("1.2 Calculating out-degree...")}
  
  # 1.1.2 out-degree
  out_degree_loc_d <- degree(sub_graph, 
                            mode = "out",
                            loops = F,
                            normalized = F)
  
  # 1.1.3 in-degree (fraudulent/non-fraudulent clients)
  
  if(verbose == T){print("1.3 Calculating fraud in-degree...")}
  # number of transactions made by fraudulent node to the specific reference node
  in_degree_fraud_loc_d <- directed_degree_counter_func(sub_graph, fraud_selection = T, degree_direction = "in")
  
  if(verbose == T){print("1.4 Calculating non-fraud in-degree...")}
  # number of transactions made by non-fraudulent node to the specific reference node
  in_degree_non_fraud_loc_d <- directed_degree_counter_func(sub_graph, fraud_selection = F, degree_direction = "in")
  
  # 1.1.4 out-degree (fraudulent/non-fraudulent clients)
  
  if(verbose == T){print("1.5 Calculating fraud out-degree...")}
  # number of transactions made by fraudulent node to the specific reference node
  out_degree_fraud_loc_d <- directed_degree_counter_func(sub_graph, fraud_selection = T, degree_direction = "out")
  
  if(verbose == T){print("1.6 Calculating non-fraud out-degree...")}
  # number of transactions made by non-fraudulent node to the specific reference node
  out_degree_non_fraud_loc_d <- directed_degree_counter_func(sub_graph, fraud_selection = F, degree_direction = "out")
  
  
  # 1.2 Compiling results in data frame
  
  if(verbose){print("Compiling calculated metrics in data frame...")}
  
  sample_network_feature_df <- data_frame(client_ID = V(sub_graph)$name,
                                          in_degree = in_degree_loc_d,
                                          in_degree_fraud = in_degree_fraud_loc_d,
                                          in_degree_non_fraud = in_degree_non_fraud_loc_d,
                                          out_degree = out_degree_loc_d,
                                          out_degree_fraud = out_degree_fraud_loc_d,
                                          out_degree_non_fraud = out_degree_non_fraud_loc_d
                                          )
  
return(sample_network_feature_df) 
  
  
  
  }

directed_network_feature_df <-  directed_network_feature_function(sub_graph = sample_network, verbose = T)


```


# 3.4 Feature extraction - Transactional data

```{r, Feature extraction - Transactional data }

# We will try and extract the following transaction information for each client:

# 1. Incoming transactions

# 1.1 Total
# 1.2 Average
# 1.4 variance

# Can drill each of down into fraud and non-fraud

# 2. Outgoing transactions

# 2.1 Total
# 2.2 Average
# 2.3 Median
# 2.4 variance

transaction_df <- edge_df

# Can drill each of down into fraud and non-fraud

# 1. Generating incoming transaction stats

incoming_transaction_stats <- transaction_df %>% 
  group_by(to) %>% 
  summarise(incoming_total = sum(weight),
            incoming_avg = mean(weight),
            incoming_sd = sd(weight),
            incoming_median = median(weight),
            incoming_max = max(weight),
            incoming_min = min(weight))


outgoing_transaction_stats <- transaction_df %>% 
  group_by(from) %>% 
  summarise(outgoing_total = sum(weight),
            outgoing_avg = mean(weight),
            outgoing_sd = sd(weight),
            outgoing_median = median(weight),
            outgoing_max = max(weight),
            outgoing_min = min(weight))

# Can try to add number of rounded transactions as well


```


# 3.5 Import of random customer information

```{r, import of random customer information}





```

# 3.6 Combination of data frames

# 4. Post-local-EDA

# 5. Global EDA (network features evolving over time)




### DEMO CODE ###

Tests code

```{r, test code}

graph <- sample_network

# names of all the nodes in the network
  node_names <- V(graph)$name 
  
  # creating variable to store fraud degree counts for each node
  fraud_degree_vec <- rep(NA, length(node_names))
  
  if(degree_direction == "in"){
    
    # looping to calculate for each fraud degree
    for (i in 1:length(node_names)) {
      
      # extracting temp sub-graph for a single node
      temp_sub_graph <- induced_subgraph(graph, 
                                         vids = unlist(neighborhood(graph = graph, order = 1, nodes = node_names[i])),
                                         impl = "auto")
      
      # converting sub-graph to data_frame and filtering
      temp_df <- as_data_frame(temp_sub_graph, what = "both")
      
      temp_edge_df <- temp_df$edges %>%
        rename(name = from)
      
      temp_fraud_count <- left_join(temp_edge_df,temp_df$vertices, by = "name") %>% 
        filter(name != node_names[i] & to == node_names[i] & is_fraud == fraud_selection) %>% 
        nrow() 
      
      # saving fraud degree
      fraud_degree_vec[i] <- temp_fraud_count
    }
  }
  
  if(degree_direction == "out"){
    
    # looping to calculate for each fraud degree
    for (i in 1:length(node_names)) {
      
      # extracting temp sub-graph for a single node
      temp_sub_graph <- induced_subgraph(graph, 
                                         vids = unlist(neighborhood(graph = graph, order = 1, nodes = node_names[i])),
                                         impl = "auto")
      
      # converting sub-graph to data_frame and filtering
      temp_df <- as_data_frame(temp_sub_graph, what = "both")
      
      temp_edge_df <- temp_df$edges %>%
        rename(name = to)
      
      temp_fraud_count <- left_join(temp_edge_df,temp_df$vertices, by = "name") %>% 
        filter(name != node_names[i] & from == node_names[i] & is_fraud == fraud_selection) %>% 
        nrow() 
      
      # saving fraud degree
      fraud_degree_vec[i] <- temp_fraud_count
    }
  }




```


Visualisations ideas
```{r, visulaisation ideas}

# visualizing weights

## box plot
boxplot(log(transactions_data_weighted$weight))

## histogram
ggplot(transactions_data_weighted, aes(x= weight)) +
  geom_histogram() +
  scale_y_log10()


# 2. Constructing un-directed weighted network 
AML_net_uw_non_simple <- graph_from_data_frame(d = transactions_data_weighted,
                                 vertices = accounts_data_up,
                                 directed = FALSE)



# degree visualizations:

# Standard degree

## histogram ()
hist(total_degree_loc, main="Histogram of Total Node Degree", xlab = "Total Degree")

## density plot
density_degree <- density(total_degree_loc)
plot(density_degree, main="Density distribution of node degree")

# Weighted degree distribution

## histogram ()
hist(weighted_degree_distribution, main="Histogram of Weighted Degree Dsitribution", xlab = "Weighted Degree")

## density plot
density_weight_degree <- density(weighted_degree_distribution)
plot(density_weight_degree, main="Density distribution of weighted node degree")

```






