---
title: "UCT Masters Minor Disseration"
author: "Gustav Oosthuizen"
date: "22/09/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Importing/Loading packages

```{r, importing/loading packages}

# 1. General workflow
library(tidyverse)
library(stringr)
library(lubridate)

# 2. Network Analytics
library(igraph)


```


# 1. Loading data

```{r, loading data}

# Note: There is three separate data files: i) accounts, ii) alerts, iii) transactions


# 1. Accounts
accounts_data_raw <- read.csv("accounts.csv")

# 2. Alerts
alerts_data_raw <- read.csv("alerts.csv")

# 3. Transactions
transactions_data_raw <- read.csv("transactions/transactions.csv")



```

# 2. Prelimimary exploratory data analysis of each data set (raw data)

```{r, prelimimary exploratory data analysis of each data set }

# 1. Accounts data

# 1.1 structure

str(accounts_data_raw)

summary(accounts_data_raw)

# 1.2 Checking uniqueness of variables

accounts_data_raw$ACCOUNT_ID %>% 
  unique() %>% 
  length()

# Note: there are 1000 accounts

accounts_data_raw$CUSTOMER_ID %>% 
  unique() %>% 
  length()

# Note: It seems like the assumption was made that the a customer only has one account.

accounts_data_raw$COUNTRY %>% 
  unique() 

# Seems like the only country is US

accounts_data_raw$ACCOUNT_TYPE %>% 
  unique()

# plotting fraudulent and not fraudent accounts

accounts_data_raw %>% 
  group_by(IS_FRAUD) %>% 
  summarise(total_count = n()) %>% 
  ggplot(aes(y = total_count, x = IS_FRAUD, fill = IS_FRAUD)) + 
  geom_col() + 
  geom_text(aes(label = total_count), vjust = 1)


# 17% is fraudulent accounts and the 83% are honest users

# plot of accounts distribution

# box and whiskers plot - initial balance

ggplot(accounts_data_raw, aes(y = IS_FRAUD, x = INIT_BALANCE)) +
  geom_boxplot()

# distribution plots

# histogram
ggplot(accounts_data_raw, aes(x = INIT_BALANCE, fill = IS_FRAUD)) +
  geom_histogram() +
  facet_wrap(~IS_FRAUD)

# density plot
ggplot(accounts_data_raw, aes(x = INIT_BALANCE, fill = IS_FRAUD)) +
  geom_density() +
  facet_wrap(~IS_FRAUD)

# 2. alerts 

str(alerts_data_raw)

summary(alerts_data_raw)

# Checking the uniqueness of each column

sapply(alerts_data_raw[sapply(alerts_data_raw, class) == "character"], unique)


# plot of alerts distribution

# box and whiskers plot - transaction amount

ggplot(alerts_data_raw, aes(x = TX_AMOUNT, y = IS_FRAUD)) +
  geom_boxplot()

# distribution - transaction amount

# histogram
ggplot(alerts_data_raw, aes(x = TX_AMOUNT)) +
  geom_histogram()

# density plot
ggplot(alerts_data_raw, aes(x = TX_AMOUNT)) +
  geom_density()

# time series plot

alerts_data_raw %>% 
ggplot(aes(x = TIMESTAMP, y = TX_AMOUNT)) + 
  geom_jitter()

# Note: No transactions were flagged that had a amount between 5 and 10 interesting to note that 

#  Histogram of received accounts

alerts_data_raw %>% 
  group_by(RECEIVER_ACCOUNT_ID) %>% 
  summarise(total_count = n()) %>% 
  arrange(desc(total_count)) %>% 
  ggplot(aes(x = total_count)) +
  geom_histogram()

#  Histogram of sender accounts

alerts_data_raw %>% 
  group_by(SENDER_ACCOUNT_ID) %>% 
  summarise(total_count = n()) %>% 
  arrange(desc(total_count)) %>% 
  ggplot(aes(x = total_count)) +
  geom_histogram()


# Count plot of the number of alert types

alerts_data_raw %>% 
  group_by(ALERT_TYPE) %>% 
  summarise(total_count = n()) %>% 
  ggplot(aes(y = total_count, x = ALERT_TYPE, fill = ALERT_TYPE)) + 
  geom_col() + 
  geom_text(aes(label = total_count), vjust = 1)


# 2. Transactions

# structure

str(transactions_data_raw)


# classes of variables

sapply(transactions_data_raw[sapply(transactions_data_raw, class) == "character"], unique)

# distributions - transactions

# box and whiskers plot
ggplot(transactions_data_raw, aes(x = TX_AMOUNT, y = IS_FRAUD)) +
  geom_boxplot() +
  scale_x_continuous(trans='log10')

# histogram
ggplot(transactions_data_raw, aes(x = TX_AMOUNT, fill = IS_FRAUD)) +
  geom_histogram() +
  facet_wrap(~IS_FRAUD) +
  scale_x_continuous(trans='log10') + 
  scale_y_continuous(trans='log10')

# density plots - fraud transactions

transactions_data_fraud <- transactions_data_raw %>% 
  filter(IS_FRAUD == "True")

# maximum density occurs at tx value of:
mode_tx_fraud <- density(transactions_data_fraud$TX_AMOUNT)$x[which.max(density(transactions_data_fraud$TX_AMOUNT)$y)]


ggplot(transactions_data_fraud, aes(TX_AMOUNT)) + 
  geom_density() + 
  geom_vline(xintercept = mode_tx_fraud)

# density plots - Non-fraud transactions (NB! something weird is heaping here!)

transactions_data_honest <- transactions_data_raw %>% 
  filter(IS_FRAUD == "False",
         TX_AMOUNT != 0)

# maximum density occurs at tx value of:
# which.max(density(transactions_data_honest$TX_AMOUNT)$y)
# 
# ggplot(transactions_data_honest, aes(TX_AMOUNT)) + 
#   geom_density() + 
#   geom_vline(xintercept = mode_tx_honest) + 
#   scale_x_log10()
         
```


# 2. Network analysis with igraph

# X. NetSciX 2016 School of Code Workshop

```{r, NetSciX 2016 School of Code Workshop}

# 1. Getting data sets ready

# 1.1 date set 1 - Media examples - unipartite graph
nodes <- read.csv("igraph_workshop_data/Dataset1-Media-Example-NODES.csv", header=T, as.is=T)
links <- read.csv("igraph_workshop_data/Dataset1-Media-Example-EDGES.csv", header=T, as.is=T)

# 1.2 examining data set
nrow(nodes)
length(unique(nodes$id))
nrow(links)
nrow(unique(links[,c("from", "to")])) # unique connections

# note: Because there is more links than unique link pairs we will aggregate their weight

# note: can also use dplr commands
links <- aggregate(links[,3], links[,-3], sum)
links <- links[order(links$from, links$to),]
colnames(links)[4] <- "weight"
rownames(links) <- NULL

# 1.3 data set 2 - Media examples - bipartite graph

nodes2 <- read.csv("igraph_workshop_data/Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)
links2 <- read.csv("igraph_workshop_data/Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)


# 2. Turing the data into igraph objects

# 2.1 data set 1 - constructing directed graph
net <- graph_from_data_frame(d=links, vertices=nodes, directed=T) # NB! creates graph from data frame 

# 2.2 inspecting network object generated
class(net)
net

# 2.3 accessing elements of the graph

E(net) # The edges of the "net" object
V(net) # The vertices of the "net" object
E(net)$type # Edge attribute "type"
V(net)$media # Vertex attribute "media"

# 2.4 plotting the network

plot(net, edge.arrow.size=.4,vertex.label=NA)

# 2.5 Remove loops in the graph using "simplify"

net <- simplify(net, remove.multiple = F, remove.loops = T)
plot(net, edge.arrow.size=.4,vertex.label=NA)

as_edgelist(net, names=T) # converts graph to an edge list
as_adjacency_matrix(net, attr="weight") # Gives you the adjecency matrix of weights of network

# convert graph back to a df
as_data_frame(net, what="edges")
as_data_frame(net, what="vertices")

# 2.6 data set 2 - bipartite graph (basically two types of nodes)

# constructing the network

net2 <- graph_from_incidence_matrix(links2)
table(V(net2)$type) # gives the two types of vertices in the newtork graph

# generating bipartite prjections
net2.bp <- bipartite.projection(net2)

# visualizing first projection
plot(net2.bp$proj1, vertex.label.color="black", vertex.label.dist=1,
vertex.size=7, vertex.label=nodes2$media[!is.na(nodes2$media.type)])

# visualising second projection
plot(net2.bp$proj2, vertex.label.color="black", vertex.label.dist=1,
vertex.size=7, vertex.label=nodes2$media[ is.na(nodes2$media.type)])

# 3. different visualization options with igraph:

# 3.1 example 1  - visualizing attributes of nodes and edges of a network

#Generate colors based on media type:
colrs <- c("gray50", "tomato", "gold")
V(net)$color <- colrs[V(net)$media.type]

# Set node size based on audience size:
V(net)$size <- V(net)$audience.size*0.7

# The labels are currently node IDs.
# Setting them to NA will render no labels:
V(net)$label.color <- "black"
V(net)$label <- NA

# Set edge width based on weight:
E(net)$width <- E(net)$weight/6

#change arrow size and edge color:
E(net)$arrow.size <- .2
E(net)$edge.color <- "gray80"
E(net)$width <- 1+E(net)$weight/12


plot(net)
legend(x=-1.5, y=-1.1, c("Newspaper","Television", "Online News"), pch=21,
col="#777777", pt.bg=colrs, pt.cex=2, cex=.8, bty="n", ncol=1)


# plotting labels of the network

plot(net, vertex.shape="none", vertex.label=V(net)$media,
vertex.label.font=2, vertex.label.color="gray40",
vertex.label.cex=.7, edge.color="gray85")

# coloring edges

edge.start <- ends(net, es=E(net), names=F)[,1]
edge.col <- V(net)$color[edge.start]
plot(net, edge.color=edge.col, edge.curved=.1)

# 4. NB! Different layout options is described especially pg 43 and 44

# 5. How to improve network plots (isolating/filtering graph on certain features)

# basic stats of the links weights
hist(links$weight)
mean(links$weight)
sd(links$weight)

# 5.1 specify cut-off weight
cut.off <- mean(links$weight)
net.sp <- delete_edges(net, E(net)[weight<cut.off])
plot(net.sp) 


# 5.2 interactive plotting with tkplot

tkid <- tkplot(net) #tkid is the id of the tkplot that will open
l <- tkplot.getcoords(tkid) # grab the coordinates from tkplot
tk_close(tkid, window.close = T)
plot(net, layout=l)

# 5.3 Other ways of representing a network

# heat map
netm <- get.adjacency(net, attr="weight", sparse=F)
colnames(netm) <- V(net)$media
rownames(netm) <- V(net)$media
palf <- colorRampPalette(c("gold", "dark orange"))
heatmap(netm[,17:1], Rowv = NA, Colv = NA, col = palf(100),
scale="none", margins=c(10,10) )


# 5.4 Plotting bipartite networks - see pg 49 and 48

# NB! 6. Generating local and global Network analytics

# 6.1 density (global)

edge_density(net, loops = F) # for undirected network

# Note: directed networks calculation showed on pg 50

# 6.2 Reciprocity - only for directed graph

# 6.3 Transitivity

# (global - ratio of triangles (direction disregarded) to connected triples.
transitivity(net, type="global") # net is treated as an undirected network
transitivity(as.undirected(net, mode="collapse")) # same as above


# (local) - ratio of triangles to connected triples each vertex is part of - NB!
transitivity(net, type="local")

# 6.4 Diameter (global)

diameter(net, directed=F, weights=NA) # global
diameter(net, directed=F) # global - weights included


# 6.5 Node degree NB! (local)

deg <- degree(net, mode = "all", loops = F)

# visualizing the degree
plot(net, vertex.size=deg*3) # the 3 is only a scaling constant

# histogram of degree
hist(deg, breaks=1:vcount(net)-1, main="Histogram of node degree")

# density plot of degree
d <- density(deg, breaks=1:vcount(net)-1)
plot(d, main="Density distribution of node degree")

# 6.6 Degree distribution
deg.dist <- degree_distribution(net, cumulative=T, mode="all")


plot( x=0:max(deg), y=1-deg.dist, pch=19, cex=1.2, col="orange",
xlab="Degree", ylab="Cumulative Frequency")

# 6.7 Centrality (local) and centralization (global)

# centrality based on degree
centr_degree(net, mode="all", normalized=T)

# closeness
closeness(net, mode="all", weights=NA)

# centrality based on closeness
centr_clo(net, mode="all", normalized=T)

# eigenvector centrality
eigen_centrality(net, directed=F, weights=NA)
# centrality based on eigenvector
centr_eigen(net, directed=T, normalized=T)

# betweenness scores - vertexes
betweenness(net, directed=T, weights=NA)

# betweenness scores - edges
edge_betweenness(net, directed=T, weights=NA)

# centrality based on betweenness
centr_betw(net, directed=T, normalized=T)

# 6.8 Hubs and Authorities - additional metric to consider to include

hs <- hub_score(net, weights=NA)$vector
as <- authority_score(net, weights=NA)$vector
par(mfrow=c(1,2))
plot(net, vertex.size=hs*50, main="Hubs")
plot(net, vertex.size=as*30, main="Authorities")


# 6.9 Distances and Paths

# average distance - global
mean_distance(net, directed=F)

# length of all shortest paths - NB! local
distances(net)

# neighbors of specific node - can calculate out degree neighbors as well as in-degree neighbors
neighbors(net, V(net)[name == "s01"], mode="all")

# Co-citation - read a bit more about this and see if you can include

cocitation(net)

# 6.10 subgroups and communities

# first simplify network to undirected network

net.sym <- as.undirected(net, mode= "collapse", edge.attr.comb=list(weight="sum", "ignore"))

# 6.10.1 Finding cliques

cliques(net.sym) # list of cliques
sapply(cliques(net.sym), length) # clique sizes
largest_cliques(net.sym) # cliques with max number of nodes

vcol <- rep("grey80", vcount(net.sym))
vcol[unlist(largest_cliques(net.sym))] <- "gold"
plot(as.undirected(net.sym), vertex.label=V(net.sym)$name, vertex.color=vcol)

# 6.10.1 Community detection

ceb <- cluster_edge_betweenness(net)
dendPlot(ceb, mode="hclust")

plot(ceb, net)

# examining communities

class(ceb)

length(ceb) # number of communities

membership(ceb) # community membership for each node

modularity(ceb) # how modular the graph partitioning is

crossing(ceb, net) # boolean vector: TRUE for edges across communities


# 6.11 K-core decomposition - page 63

# 6.12 Assortativity and Homophily

```

# 2.1 Network analysis with simulated AML data

```{r, network analysis with simulated AML data }

# 1. Data preparation

# 1.1 transactions data & alerts data 

# joining alter type col from alerts df to transactions df 

alerts_types <- alerts_data_raw %>% 
  select(ALERT_ID, ALERT_TYPE)

transactions_data_up <- transactions_data_raw %>% 
  left_join(alerts_types, by = "ALERT_ID") %>% 
  unique()

# replacing NA values formed by transactions that are not fraud

transactions_data_up[is.na(transactions_data_up)] <- "No Alert"

# rearranging columns such that sender node and receiver node is mentioned first in the df

transactions_data_up <- transactions_data_up[,c(2,3,1,4:ncol(transactions_data_up))]

# 2. Configuring nodes and edges of network

# 2.1 Initial checks

# nodes - accounts

nrow(accounts_data_raw)

accounts_data_raw$ACCOUNT_ID %>%
  unique() %>% 
  length()
  
# Note: there are 1000 different accounts

# links - transactions

nrow(transactions_data_up)

nrow(unique(transactions_data_up[,c("SENDER_ACCOUNT_ID", "RECEIVER_ACCOUNT_ID")]))

# Note: There are more links than sender-receiver combination, therefore we have cases where there is multiple links between the same nodes

# 2.2 defining weight value for transactions - aggregating the transaction by summing their amounts

# Note: The below code gives a weight to a directed graph, therefore the sender-receiver weight can be different than the same receiver-sender weight. Look the code chunk starting at 2.2.1 

# transactions_data_up <- aggregate(transactions_data_up[,5], transactions_data_up[,-5], sum)
# transactions_data_up <- transactions_data_up[order(transactions_data_up$SENDER_ACCOUNT_ID,transactions_data_up$RECEIVER_ACCOUNT_ID),]
# 
# colnames(transactions_data_up)[9] <- "weight"
# rownames(transactions_data_up) <- NULL


# 2.2.1 Defining unique client-pair ID's

# Note: for now, we will assume that the wight between two nodes connected by an edge are the same and that the weight is calculated as the sum of the transaction amount between the two nodes.

# Note: we are working from the basis of sender-receiver, therefore if we have the case where the concatenate the receiver sender and it is the same as the sender-receiver, we know it is not a unique pair

# Gustav's way - not working
# # adding sender-receiver and receiver-sender ID combos to transaction df 
# transactions_data_up_combos <- transactions_data_up %>% 
#   mutate(id_combo_sender_receiver = paste0(SENDER_ACCOUNT_ID,RECEIVER_ACCOUNT_ID),
#          id_combo_receiver_sender = paste0(RECEIVER_ACCOUNT_ID,SENDER_ACCOUNT_ID)) #%>% 
#  #mutate(duplicates = if_else(id_combo_receiver_sender %in% id_combo_sender_receiver, T,F) )
# 
# # creating a data frame that contains all the unique client-pairs 
# combo_ids_combined <- data.frame(combo_ids = c(transactions_data_up_combos$id_combo_sender_receiver, transactions_data_up_combos$id_combo_receiver_sender)) %>% 
#   unique()
# 
# # assigning each client pair with a new ID
# combo_ids_combined <- combo_ids_combined %>% 
#   mutate(client_pair_id = 1:nrow(combo_ids_combined)) %>% 
#   rename(id_combo_sender_receiver = combo_ids)
# 
# # joining client ID's to the 
# transactions_data_up_client_pairs <- left_join(transactions_data_up_combos, combo_ids_combined, by = "id_combo_sender_receiver") %>% 
#   select(-c(id_combo_sender_receiver,id_combo_receiver_sender))


# i-graph implementation: generating un-directed network and then converting back to data frame to calculate weights and defining send-receive combo
transactions_data_up_paired <- unique(as_data_frame(graph_from_data_frame(transactions_data_up, directed=FALSE), "edges")) %>%
  mutate(send_receive_id_combo = paste0(from,"-",to))
  

# number of unique client pairs
unique_client_pairs <- transactions_data_up_paired[,c("from", "to")] %>%
  unique()
  
# configuring weights of network - attribute of edges

# Note: The weight is currently determined by the total transaction amount that occurred between the parties

edge_weights <- transactions_data_up_paired %>% 
  group_by(from, to) %>% 
  summarise(weight = sum(TX_AMOUNT)) %>% 
  mutate(send_receive_id_combo = paste0(from,"-",to))
  

edge_weights <- edge_weights[,-c(1,2)]

# joining to transactional

transactions_data_weighted <- left_join(transactions_data_up_paired, edge_weights, by = "send_receive_id_combo") %>% 
  unique()


# Et: should I normalise the weight?  

# Visualizing weights

# boxplot
boxplot(log(transactions_data_weighted$weight))

# histogram
ggplot(transactions_data_weighted, aes(x= weight)) +
  geom_histogram() +
  scale_y_log10()


# Note: the weights seem strange so the I tested them using:
# test <- transactions_data_up_paired %>% 
#   filter(from == "7123" & to == "9637")


# 2.3 turning df's into igraph objects

AML_net <- graph_from_data_frame(d = transactions_data_weighted,
                                 vertices = accounts_data_raw,
                                 directed = FALSE)

# Note: That the we are constructing a un-directed graph

# 2.4 Inspecting graph created object

AML_net

# Note: We can see by DNW that it is a Directed-Named-Weighted graph


# nodes of the network
V(AML_net)

V(AML_net)$INIT_BALANCE # how to subset vertices network attributes

# edges of the network
E(AML_net)

E(AML_net)$IS_FRAUD # how to subset edge network attributes


# visualizing the network (can try to do this later)

#plot(AML_net, vertex.label = F, layout = layout_with_lgl)

# Note: An EDA of the global features of the network kan be done or global metrics can be used as indicators of the networks evolution (can also be done for fraud and non-fraud)


# 3. Populating feature dataframe of network metrics (local features)

# creating netork feature data frame
network_feature_df <- data_frame(ACCOUNT_ID = accounts_data_raw$ACCOUNT_ID)

# 3.1 Neighbourhood metrics

# 3.1.1 Transitivity - (local) ratio of triangles to connected triples each vertex is part of. Can be interpreted as a probability for the network to have adjacent nodes interconnected, thus revealing the existence of tightly connected communities (or clusters, subgroups, cliques).

transitivity_loc <- transitivity(AML_net, type="local")


# Note: If a node has a degree of zero then the transitivity will be NaN. Think of a way how you can treat this.

# transforming all NaN values to zero
#transitivity_loc[is.na(transitivity_loc)] <- 0

# adding transitivity to df
network_feature_df$transitivity_local <- transitivity_loc

# 3.1.2 Degree (local)

# Note: This will be the total degree, Baesens et al. (2015) splitted the total degree into: total fraud and total legit degree

total_degree_loc <- degree(AML_net, loops = F)

# degree visualisations:

# histogram
hist(total_degree_loc, breaks=1:vcount(AML_net)-1, main="Histogram of Total Node Degree", xlab = "Total Degree")

# density plot
d <- density(total_degree_loc, breaks=1:vcount(AML_net)-1)
plot(d, main="Density distribution of node degree")

# adding total degree to df
network_feature_df$total_degree_local <- total_degree_loc

# 3.1.2 Cocitation coupling (local) - siply counts how many types two vertices are cocited (there is another vertex citing both of them).

cocitation_loc <- cocitation(AML_net)

# adding total degree to df
network_feature_df$cocitation_count <- cocitation_loc

# 3.2 Centrality metrics

# 3.2.1 Closeness centrality - Measures the average farness (inverse distance) to all other nodes. Nodes with a high closeness score have the shortest distances to all other nodes.

centrality_closeness_loc <- closeness(AML_net, normalized = T) # takes +/- 10 mins

# Note: We need to standardize to get the average farness. This metric, by default, also uses the weighted features.

# adding closeness centrality to df
network_feature_df$centrality_closeness <- centrality_closeness_loc

# 3.2.2 Eigenvector centrality - Eigenvector centrality scores correspond to the values of the first eigenvector of the graph adjacency matrix; these scores may, in turn, be interpreted as arising from a reciprocal process in which the centrality of each actor is proportional to the sum of the centralities of those actors to whom he or she is connected.

centrality_eigen_loc <- eigen_centrality(AML_net,
                                         scale = T,
                                         directed=F)

# Note: edge weights are incorporated in calculation

# adding closeness centrality to df
network_feature_df$centrality_eigen_vector <- centrality_eigen_loc$vector


# 3.2.3 betweeness - the number of geodesics (shortest paths) going through a vertex or an edge

centrality_betweenness_loc <-  betweenness(AML_net, 
                                           directed=F)

# adding betweenness centrality to df
network_feature_df$centrality_betweenness <- centrality_betweenness_loc # takes +/- 10 mins


# Note: edge weights are incorporated in calculation

# 3.2.4 Kleinberg's hub and authority centrality scores - defined as the principal eigenvector of t(A)*A, where A is the adjacency matrix of the graph.

centrality_hub_score_loc <- hub_score(AML_net,
                                  scale = T)

# Note: For un-directed networks the hub authority scores are the same. If a directed network is implemented we can calculate both. 

# adding Kleinberg's hub/authority score centrality to df
network_feature_df$centrality_hub_score <- centrality_hub_score_loc$vector

# 3.3 Distances and Paths

# 3.3.1  Geodesic - length of all shortest paths

geodesic_loc <- distances(AML_net,
                          algorithm = "automatic") #Big NXN matrix

# Note: edge weights are incorporated in calculation

avg_geodesic_loc <- mean_distance(AML_net,
                                  directed = F,
                                  unconnected = T) # removing first row since it is not connected 

# adding avg_geodesic to df
network_feature_df$avg_geodesic <- avg_geodesic_loc

# 3.4 Triangles - Count how many triangles a vertex is part of, in a graph, or just list the triangles of a graph.

triangles_loc <- count_triangles(AML_net)

# Note: This will be the total triangles Baesens et al. (2015) broke this up into: total fraud triangles, total legit triangles, and total semi-fraud triangles. 

# adding triangles to df
network_feature_df$triangles <- triangles_loc

# 3.5 Inference algorithms 

# 3.5.1 PageRank

pr <- page_rank(AML_net,
                algo = "prpack",
                directed = F,
                damping = 0.85) 

# Note: Look at what damping factors are suitable and how it should be chosen

# adding PageRank to df
network_feature_df$page_rank <- pr$vector


# wrinting csv

write.csv(as.data.frame(network_feature_df), file = "gustav_preliminary_network_features.csv")

```






