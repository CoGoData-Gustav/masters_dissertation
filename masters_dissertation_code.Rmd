---
title: "UCT Masters Minor Disseration"
author: "Gustav Oosthuizen"
date: "22/09/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Importing/Loading packages

```{r, importing/loading packages}

# 1. General workflow
library(tidyverse)
library(stringr)
library(lubridate)

# 2. Network Analytics
library(igraph)


```


# 1. Loading data

```{r, loading data}

# Note: There is three separate data files: i) accounts, ii) alerts, iii) transactions


# 1. Accounts
accounts_data_raw <- read.csv("accounts.csv")

# 2. Alerts
alerts_data_raw <- read.csv("alerts.csv")

# 3. Transactions
transactions_data_raw <- read.csv("transactions/transactions.csv")



```

# 2. Prelimimary exploratory data analysis of each data set (raw data)

```{r, prelimimary exploratory data analysis of each data set }

# 1. Accounts data

# 1.1 structure

str(accounts_data_raw)

summary(accounts_data_raw)

# 1.2 Checking uniqueness of variables

accounts_data_raw$ACCOUNT_ID %>% 
  unique() %>% 
  length()

# Note: there are 1000 accounts

accounts_data_raw$CUSTOMER_ID %>% 
  unique() %>% 
  length()

# Note: It seems like the assumption was made that the a customer only has one account.

accounts_data_raw$COUNTRY %>% 
  unique() 

# Seems like the only country is US

accounts_data_raw$ACCOUNT_TYPE %>% 
  unique()

# plotting fraudulent and not fraudent accounts

accounts_data_raw %>% 
  group_by(IS_FRAUD) %>% 
  summarise(total_count = n()) %>% 
  ggplot(aes(y = total_count, x = IS_FRAUD, fill = IS_FRAUD)) + 
  geom_col() + 
  geom_text(aes(label = total_count), vjust = 1)


# 17% is fraudulent accounts and the 83% are honest users

# plot of accounts distribution

# box and whiskers plot - initial balance

ggplot(accounts_data_raw, aes(y = IS_FRAUD, x = INIT_BALANCE)) +
  geom_boxplot()

# distribution plots

# histogram
ggplot(accounts_data_raw, aes(x = INIT_BALANCE, fill = IS_FRAUD)) +
  geom_histogram() +
  facet_wrap(~IS_FRAUD)

# density plot
ggplot(accounts_data_raw, aes(x = INIT_BALANCE, fill = IS_FRAUD)) +
  geom_density() +
  facet_wrap(~IS_FRAUD)

# 2. alerts 

str(alerts_data_raw)

summary(alerts_data_raw)

# Checking the uniqueness of each column

sapply(alerts_data_raw[sapply(alerts_data_raw, class) == "character"], unique)


# plot of alerts distribution

# box and whiskers plot - transaction amount

ggplot(alerts_data_raw, aes(x = TX_AMOUNT, y = IS_FRAUD)) +
  geom_boxplot()

# distribution - transaction amount

# histogram
ggplot(alerts_data_raw, aes(x = TX_AMOUNT)) +
  geom_histogram()

# density plot
ggplot(alerts_data_raw, aes(x = TX_AMOUNT)) +
  geom_density()

# time series plot

alerts_data_raw %>% 
ggplot(aes(x = TIMESTAMP, y = TX_AMOUNT)) + 
  geom_jitter()

# Note: No transactions were flagged that had a amount between 5 and 10 interesting to note that 

#  Histogram of received accounts

alerts_data_raw %>% 
  group_by(RECEIVER_ACCOUNT_ID) %>% 
  summarise(total_count = n()) %>% 
  arrange(desc(total_count)) %>% 
  ggplot(aes(x = total_count)) +
  geom_histogram()

#  Histogram of sender accounts

alerts_data_raw %>% 
  group_by(SENDER_ACCOUNT_ID) %>% 
  summarise(total_count = n()) %>% 
  arrange(desc(total_count)) %>% 
  ggplot(aes(x = total_count)) +
  geom_histogram()


# Count plot of the number of alert types

alerts_data_raw %>% 
  group_by(ALERT_TYPE) %>% 
  summarise(total_count = n()) %>% 
  ggplot(aes(y = total_count, x = ALERT_TYPE, fill = ALERT_TYPE)) + 
  geom_col() + 
  geom_text(aes(label = total_count), vjust = 1)


# 2. Transactions

# structure

str(transactions_data_raw)


# classes of variables

sapply(transactions_data_raw[sapply(transactions_data_raw, class) == "character"], unique)

# distributions - transactions

# box and whiskers plot
ggplot(transactions_data_raw, aes(x = TX_AMOUNT, y = IS_FRAUD)) +
  geom_boxplot() +
  scale_x_continuous(trans='log10')

# histogram
ggplot(transactions_data_raw, aes(x = TX_AMOUNT, fill = IS_FRAUD)) +
  geom_histogram() +
  facet_wrap(~IS_FRAUD) +
  scale_x_continuous(trans='log10') + 
  scale_y_continuous(trans='log10')

# density plots - fraud transactions

transactions_data_fraud <- transactions_data_raw %>% 
  filter(IS_FRAUD == "True")

# maximum density occurs at tx value of:
mode_tx_fraud <- density(transactions_data_fraud$TX_AMOUNT)$x[which.max(density(transactions_data_fraud$TX_AMOUNT)$y)]


ggplot(transactions_data_fraud, aes(TX_AMOUNT)) + 
  geom_density() + 
  geom_vline(xintercept = mode_tx_fraud)

# density plots - Non-fraud transactions (NB! something weird is heaping here!)

transactions_data_honest <- transactions_data_raw %>% 
  filter(IS_FRAUD == "False",
         TX_AMOUNT != 0)

# maximum density occurs at tx value of:
# which.max(density(transactions_data_honest$TX_AMOUNT)$y)
# 
# ggplot(transactions_data_honest, aes(TX_AMOUNT)) + 
#   geom_density() + 
#   geom_vline(xintercept = mode_tx_honest) + 
#   scale_x_log10()
         
```


# 2. Network analysis with igraph

# X. NetSciX 2016 School of Code Workshop

```{r, NetSciX 2016 School of Code Workshop}

# 1. Getting data sets ready

# 1.1 date set 1 - Media examples - unipartite graph
nodes <- read.csv("igraph_workshop_data/Dataset1-Media-Example-NODES.csv", header=T, as.is=T)
links <- read.csv("igraph_workshop_data/Dataset1-Media-Example-EDGES.csv", header=T, as.is=T)

# 1.2 examining data set
nrow(nodes)
length(unique(nodes$id))
nrow(links)
nrow(unique(links[,c("from", "to")])) # unique connections

# note: Because there is more links than unique link pairs we will aggregate their weight

# note: can also use dplr commands
links <- aggregate(links[,3], links[,-3], sum)
links <- links[order(links$from, links$to),]
colnames(links)[4] <- "weight"
rownames(links) <- NULL

# 1.3 data set 2 - Media examples - bipartite graph

nodes2 <- read.csv("igraph_workshop_data/Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)
links2 <- read.csv("igraph_workshop_data/Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)


# 2. Turing the data into igraph objects

# 2.1 data set 1 - constructing directed graph
net <- graph_from_data_frame(d=links, vertices=nodes, directed=T) # NB! creates graph from data frame 

# 2.2 inspecting network object generated
class(net)
net

# 2.3 accessing elements of the graph

E(net) # The edges of the "net" object
V(net) # The vertices of the "net" object
E(net)$type # Edge attribute "type"
V(net)$media # Vertex attribute "media"

# 2.4 plotting the network

plot(net, edge.arrow.size=.4,vertex.label=NA)

# 2.5 Remove loops in the graph using "simplify"

net <- simplify(net, remove.multiple = F, remove.loops = T)
plot(net, edge.arrow.size=.4,vertex.label=NA)

as_edgelist(net, names=T) # converts graph to an edge list
as_adjacency_matrix(net, attr="weight") # Gives you the adjecency matrix of weights of network

# convert graph back to a df
as_data_frame(net, what="edges")
as_data_frame(net, what="vertices")

# 2.6 data set 2 - bipartite graph (basically two types of nodes)

# constructing the network

net2 <- graph_from_incidence_matrix(links2)
table(V(net2)$type) # gives the two types of vertices in the newtork graph

# generating bipartite prjections
net2.bp <- bipartite.projection(net2)

# visualizing first projection
plot(net2.bp$proj1, vertex.label.color="black", vertex.label.dist=1,
vertex.size=7, vertex.label=nodes2$media[!is.na(nodes2$media.type)])

# visualising second projection
plot(net2.bp$proj2, vertex.label.color="black", vertex.label.dist=1,
vertex.size=7, vertex.label=nodes2$media[ is.na(nodes2$media.type)])

# 3. different visualization options with igraph:

# 3.1 example 1  - visualizing attributes of nodes and edges of a network

#Generate colors based on media type:
colrs <- c("gray50", "tomato", "gold")
V(net)$color <- colrs[V(net)$media.type]

# Set node size based on audience size:
V(net)$size <- V(net)$audience.size*0.7

# The labels are currently node IDs.
# Setting them to NA will render no labels:
V(net)$label.color <- "black"
V(net)$label <- NA

# Set edge width based on weight:
E(net)$width <- E(net)$weight/6

#change arrow size and edge color:
E(net)$arrow.size <- .2
E(net)$edge.color <- "gray80"
E(net)$width <- 1+E(net)$weight/12


plot(net)
legend(x=-1.5, y=-1.1, c("Newspaper","Television", "Online News"), pch=21,
col="#777777", pt.bg=colrs, pt.cex=2, cex=.8, bty="n", ncol=1)


# plotting labels of the network

plot(net, vertex.shape="none", vertex.label=V(net)$media,
vertex.label.font=2, vertex.label.color="gray40",
vertex.label.cex=.7, edge.color="gray85")

# coloring edges

edge.start <- ends(net, es=E(net), names=F)[,1]
edge.col <- V(net)$color[edge.start]
plot(net, edge.color=edge.col, edge.curved=.1)

# 4. NB! Different layout options is described especially pg 43 and 44

# 5. How to improve network plots (isolating/filtering graph on certain features)

# basic stats of the links weights
hist(links$weight)
mean(links$weight)
sd(links$weight)

# 5.1 specify cut-off weight
cut.off <- mean(links$weight)
net.sp <- delete_edges(net, E(net)[weight<cut.off])
plot(net.sp) 


# 5.2 interactive plotting with tkplot

tkid <- tkplot(net) #tkid is the id of the tkplot that will open
l <- tkplot.getcoords(tkid) # grab the coordinates from tkplot
tk_close(tkid, window.close = T)
plot(net, layout=l)

# 5.3 Other ways of representing a network

# heat map
netm <- get.adjacency(net, attr="weight", sparse=F)
colnames(netm) <- V(net)$media
rownames(netm) <- V(net)$media
palf <- colorRampPalette(c("gold", "dark orange"))
heatmap(netm[,17:1], Rowv = NA, Colv = NA, col = palf(100),
scale="none", margins=c(10,10) )


# 5.4 Plotting bipartite networks - see pg 49 and 48

# NB! 6. Generating local and global Network analytics

# 6.1 density (global)

edge_density(net, loops = F) # for undirected network

# Note: directed networks calculation showed on pg 50

# 6.2 Reciprocity - only for directed graph

# 6.3 Transitivity

# (global - ratio of triangles (direction disregarded) to connected triples.
transitivity(net, type="global") # net is treated as an undirected network
transitivity(as.undirected(net, mode="collapse")) # same as above


# (local) - ratio of triangles to connected triples each vertex is part of - NB!
transitivity(net, type="local")

# 6.4 Diameter (global)

diameter(net, directed=F, weights=NA) # global
diameter(net, directed=F) # global - weights included


# 6.5 Node degree NB! (local)

deg <- degree(net, mode = "all", loops = F)

# visualizing the degree
plot(net, vertex.size=deg*3) # the 3 is only a scaling constant

# histogram of degree
hist(deg, breaks=1:vcount(net)-1, main="Histogram of node degree")

# density plot of degree
d <- density(deg, breaks=1:vcount(net)-1)
plot(d, main="Density distribution of node degree")

# 6.6 Degree distribution
deg.dist <- degree_distribution(net, cumulative=T, mode="all")


plot( x=0:max(deg), y=1-deg.dist, pch=19, cex=1.2, col="orange",
xlab="Degree", ylab="Cumulative Frequency")

# 6.7 Centrality (local) and centralization (global)

# centrality based on degree
centr_degree(net, mode="all", normalized=T)

# closeness
closeness(net, mode="all", weights=NA)

# centrality based on closeness
centr_clo(net, mode="all", normalized=T)

# eigenvector centrality
eigen_centrality(net, directed=F, weights=NA)
# centrality based on eigenvector
centr_eigen(net, directed=T, normalized=T)

# betweenness scores - vertexes
betweenness(net, directed=T, weights=NA)

# betweenness scores - edges
edge_betweenness(net, directed=T, weights=NA)

# centrality based on betweenness
centr_betw(net, directed=T, normalized=T)

# 6.8 Hubs and Authorities - additional metric to consider to include

hs <- hub_score(net, weights=NA)$vector
as <- authority_score(net, weights=NA)$vector
par(mfrow=c(1,2))
plot(net, vertex.size=hs*50, main="Hubs")
plot(net, vertex.size=as*30, main="Authorities")


# 6.9 Distances and Paths

# average distance - global
mean_distance(net, directed=F)

# length of all shortest paths - NB! local
distances(net)

# neighbors of specific node - can calculate out degree neighbors as well as in-degree neighbors
neighbors(net, V(net)[name == "s01"], mode="all")

# Co-citation - read a bit more about this and see if you can include

cocitation(net)

# 6.10 subgroups and communities

# first simplify network to undirected network

net.sym <- as.undirected(net, mode= "collapse", edge.attr.comb=list(weight="sum", "ignore"))

# 6.10.1 Finding cliques

cliques(net.sym) # list of cliques
sapply(cliques(net.sym), length) # clique sizes
largest_cliques(net.sym) # cliques with max number of nodes

vcol <- rep("grey80", vcount(net.sym))
vcol[unlist(largest_cliques(net.sym))] <- "gold"
plot(as.undirected(net.sym), vertex.label=V(net.sym)$name, vertex.color=vcol)

# 6.10.1 Community detection

ceb <- cluster_edge_betweenness(net)
dendPlot(ceb, mode="hclust")

plot(ceb, net)

# examining communities

class(ceb)

length(ceb) # number of communities

membership(ceb) # community membership for each node

modularity(ceb) # how modular the graph partitioning is

crossing(ceb, net) # boolean vector: TRUE for edges across communities


# 6.11 K-core decomposition - page 63

# 6.12 Assortativity and Homophily

```

# 2.1 Network analysis with simulated AML data

```{r, network analysis with simulated AML data }

# 1. Data preparation

# 1.1 transactions data & alerts data 

# joining alter type col from alerts df to transactions df 

alerts_types <- alerts_data_raw %>% 
  select(ALERT_ID, ALERT_TYPE)

transactions_data_up <- transactions_data_raw %>% 
  left_join(alerts_types, by = "ALERT_ID") %>% 
  unique()

# replacing NA values formed by transactions that are not fraud

transactions_data_up[is.na(transactions_data_up)] <- "No Alert"

# rearranging columns such that sender node and receiver node is mentioned first in the df

transactions_data_up <- transactions_data_up[,c(2,3,1,4:ncol(transactions_data_up))]

# 2. Configuring nodes and edges of network

# 2.1 Initial checks

# nodes - accounts

nrow(accounts_data_raw)

accounts_data_raw$ACCOUNT_ID %>%
  unique() %>% 
  length()
  
# Note: there are 1000 different accounts

# links - transactions

nrow(transactions_data_up)

nrow(unique(transactions_data_up[,c("SENDER_ACCOUNT_ID", "RECEIVER_ACCOUNT_ID")]))

# Note: There are more links than sender-receiver combination, therefore we have cases where there is multiple links between the same nodes

# 2.2 defining weight value for transactions - aggregating the transaction by summing their amounts


transactions_data_up <- aggregate(transactions_data_up[,5], transactions_data_up[,-5], sum)
transactions_data_up <- transactions_data_up[order(transactions_data_up$SENDER_ACCOUNT_ID,transactions_data_up$RECEIVER_ACCOUNT_ID),]

colnames(transactions_data_up)[9] <- "weight"
rownames(transactions_data_up) <- NULL

# 2.3 turning df's into igraph objects

AML_net <- graph_from_data_frame(d = transactions_data_up,
                                 vertices = accounts_data_raw)

# 2.4 Inspecting graph created object

AML_net

# Note: We can see by DNW that it is a Directed-Named-Weighted graph


# nodes of the network
V(AML_net)

V(AML_net)$INIT_BALANCE # how to subset vertices network attributes

# edges of the network
E(AML_net)

E(AML_net)$IS_FRAUD # how to subset edge network attributes


# visualizing the network (can try to do this later)

#plot(AML_net, vertex.label = F, layout = layout_with_lgl)

# Note: An EDA of the global features of the network kan be done or global metrics can be used as indicators of the networks evolution.


# 3. Populating feature dataframe of network metrics (local features)


# 3.1 Transitivity - (local) ratio of triangles to connected triples each vertex is part of.

transitivity_loc <- transitivity(AML_net, type="local")

# transforming all NaN values to zero

transitivity_loc[is.na(transitivity_loc)] <- 0

# Note: what is an appropriate scaling method? Maybe we should first scale when we have all the mretrics?


node_0_graph <- make_ego_graph(AML_net,
                               order = 3,
                               nodes = 1,
                               mode = "all")





```






